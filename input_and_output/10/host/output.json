{"version":"2.0, build 20191126_034138","type":"hodor_studenttester","contentRoot":"/student","testRoot":"/tester","results":[{"code":101,"count":0,"errors":[],"identifier":"CHECKSTYLE","result":"SUCCESS"},{"code":103,"files":[{"path":"checkstyle.xml","contents":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE module PUBLIC \"-//Puppy Crawl//DTD Check Configuration 1.2//EN\" \"http://www.puppycrawl.com/dtds/configuration_1_2.dtd\">\n<!--\n\n  Checkstyle configuration that checks the sun coding conventions from:\n\n    - the Java Language Specification at\n      http://java.sun.com/docs/books/jls/second_edition/html/index.html\n\n    - the Sun Code Conventions at http://java.sun.com/docs/codeconv/\n\n    - the Javadoc guidelines at\n      http://java.sun.com/j2se/javadoc/writingdoccomments/index.html\n\n    - the JDK Api documentation http://java.sun.com/j2se/docs/api/index.html\n\n    - some best practices\n\n  Checkstyle is very configurable. Be sure to read the documentation at\n  http://checkstyle.sf.net (or in your downloaded distribution).\n\n  Most Checks are configurable, be sure to consult the documentation.\n\n  To completely disable a check, just comment it out or delete it from the file.\n\n  Finally, it is worth reading the documentation.\n\n-->\n<module name=\"Checker\">\n    <property name=\"charset\" value=\"UTF-8\"/>\n    <!--\n        If you set the basedir property below, then all reported file\n        names will be relative to the specified directory. See\n        http://checkstyle.sourceforge.net/5.x/config.html#Checker\n\n        <property name=\"basedir\" value=\"${basedir}\"/>\n    -->\n\n    <!-- Checks that a package-info.java file exists for each package.     -->\n    <!-- See http://checkstyle.sf.net/config_javadoc.html#JavadocPackage -->\n    <!--\n    <module name=\"JavadocPackage\"/>\n    -->\n\n    <!-- Checks whether files end with a new line.                        -->\n    <!-- See http://checkstyle.sf.net/config_misc.html#NewlineAtEndOfFile -->\n    <module name=\"NewlineAtEndOfFile\">\n        <property name=\"fileExtensions\" value=\"java, xml, py, css, fxml\"/>\n    </module>\n\n    <!-- Checks that property files contain the same keys.         -->\n    <!-- See http://checkstyle.sf.net/config_misc.html#Translation -->\n    <module name=\"Translation\"/>\n\n    <!-- Checks for Size Violations.                    -->\n    <!-- See http://checkstyle.sf.net/config_sizes.html -->\n    <module name=\"FileLength\"/>\n\n    <!-- Checks for whitespace                               -->\n    <!-- See http://checkstyle.sf.net/config_whitespace.html -->\n    <module name=\"FileTabCharacter\"/>\n\n    <!-- Miscellaneous other checks.                   -->\n    <!-- See http://checkstyle.sf.net/config_misc.html -->\n    <module name=\"RegexpSingleline\">\n        <property name=\"format\" value=\"\\s+$\"/>\n        <property name=\"minimum\" value=\"0\"/>\n        <property name=\"maximum\" value=\"0\"/>\n        <property name=\"message\" value=\"Line has trailing spaces.\"/>\n    </module>\n\n    <module name=\"TreeWalker\">\n\n        <!-- Checks for Javadoc comments.                     -->\n        <!-- See http://checkstyle.sf.net/config_javadoc.html -->\n\n\n        <!-- Checks for Naming Conventions.                  -->\n        <!-- See http://checkstyle.sf.net/config_naming.html -->\n        <module name=\"ConstantName\"/>\n        <!--\n            <module name=\"LocalFinalVariableName\"/>\n        -->\n        <module name=\"LocalVariableName\"/>\n        <module name=\"MemberName\"/>\n        <module name=\"MethodName\"/>\n        <module name=\"PackageName\"/>\n        <module name=\"ParameterName\"/>\n        <module name=\"StaticVariableName\"/>\n        <module name=\"TypeName\"/>\n\n\n        <!-- Checks for Headers                                -->\n        <!-- See http://checkstyle.sf.net/config_header.html   -->\n        <!-- <module name=\"Header\">                            -->\n        <!-- The follow property value demonstrates the ability     -->\n        <!-- to have access to ANT properties. In this case it uses -->\n        <!-- the ${basedir} property to allow Checkstyle to be run  -->\n        <!-- from any directory within a project. See property      -->\n        <!-- expansion,                                             -->\n        <!-- http://checkstyle.sf.net/config.html#properties        -->\n        <!-- <property                                              -->\n        <!--     name=\"headerFile\"                                  -->\n        <!--     value=\"${basedir}/java.header\"/>                   -->\n        <!-- </module> -->\n\n        <!-- Following interprets the header file as regular expressions. -->\n        <!-- <module name=\"RegexpHeader\"/>                                -->\n\n\n        <!-- Checks for imports                              -->\n        <!-- See http://checkstyle.sf.net/config_import.html -->\n        <module name=\"AvoidStarImport\"/>\n        <module name=\"IllegalImport\"/> <!-- defaults to sun.* packages -->\n        <module name=\"RedundantImport\"/>\n        <module name=\"UnusedImports\"/>\n\n\n        <!-- Checks for Size Violations.                    -->\n        <!-- See http://checkstyle.sf.net/config_sizes.html -->\n        <module name=\"LineLength\">\n            <property name=\"max\" value=\"120\"/>\n        </module>\n        <module name=\"MethodLength\"/>\n        <module name=\"ParameterNumber\"/>\n\n\n        <!-- Checks for whitespace                               -->\n        <!-- See http://checkstyle.sf.net/config_whitespace.html -->\n        <module name=\"EmptyForIteratorPad\"/>\n        <module name=\"GenericWhitespace\"/>\n        <module name=\"MethodParamPad\"/>\n        <module name=\"NoWhitespaceAfter\"/>\n        <module name=\"NoWhitespaceBefore\"/>\n        <module name=\"OperatorWrap\"/>\n        <module name=\"ParenPad\"/>\n        <module name=\"TypecastParenPad\"/>\n        <module name=\"WhitespaceAfter\"/>\n        <module name=\"WhitespaceAround\"/>\n\n\n        <!-- Modifier Checks                                    -->\n        <!-- See http://checkstyle.sf.net/config_modifiers.html -->\n        <module name=\"ModifierOrder\"/>\n        <module name=\"RedundantModifier\"/>\n\n\n        <!-- Checks for blocks. You know, those {}'s         -->\n        <!-- See http://checkstyle.sf.net/config_blocks.html -->\n        <module name=\"AvoidNestedBlocks\"/>\n        <module name=\"EmptyBlock\"/>\n        <module name=\"LeftCurly\"/>\n        <module name=\"NeedBraces\">\n            <property name=\"allowSingleLineStatement\" value=\"true\"/>\n        </module>\n        <module name=\"RightCurly\"/>\n\n\n        <!-- Checks for common coding problems               -->\n        <!-- See http://checkstyle.sf.net/config_coding.html -->\n        <!-- module name=\"AvoidInlineConditionals\"/ -->\n        <module name=\"EmptyStatement\"/>\n        <module name=\"EqualsHashCode\"/>\n        <!--\n            <module name=\"HiddenField\">\n                <property name=\"ignoreSetter\" value=\"true\"/>\n        </module>\n        -->\n        <module name=\"IllegalInstantiation\"/>\n        <module name=\"InnerAssignment\"/>\n        <module name=\"MagicNumber\">\n            <property name=\"ignoreNumbers\" value=\"-5,-4,-3,-2,-1,0,1,2,3,4,5,10,100,1000\"/>\n        </module>\n        <module name=\"MissingSwitchDefault\"/>\n        <module name=\"SimplifyBooleanExpression\"/>\n        <module name=\"SimplifyBooleanReturn\"/>\n\n        <!-- Checks for class design                         -->\n        <!-- See http://checkstyle.sf.net/config_design.html -->\n        <!--\n            <module name=\"DesignForExtension\"/>\n        -->\n        <module name=\"FinalClass\"/>\n        <!--\n            <module name=\"HideUtilityClassConstructor\"/>\n        -->\n        <module name=\"InterfaceIsType\"/>\n        <!--\n            <module name=\"VisibilityModifier\"/>\n        -->\n\n\n        <!-- Miscellaneous other checks.                   -->\n        <!-- See http://checkstyle.sf.net/config_misc.html -->\n        <module name=\"ArrayTypeStyle\"/>\n        <!--\n            <module name=\"FinalParameters\"/>\n        -->\n        <module name=\"TodoComment\"/>\n        <module name=\"UpperEll\"/>\n\n    </module>\n\n\n</module>","isTest":true},{"path":"src/ee/taltech/iti0202/strings/MainTest.java","contents":"package ee.taltech.iti0202.strings;\n\nimport ee.ttu.java.studenttester.annotations.TestContextConfiguration;\nimport ee.ttu.java.studenttester.enums.ReportMode;\nimport org.testng.annotations.Test;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.testng.Assert.assertTrue;\n\n@TestContextConfiguration(mode = ReportMode.VERBOSE)\npublic class MainTest {\n\n    @Test(timeOut = 1000)\n    public void testWordCount() {\n        Map<String, Integer> actual = Main.wordCount(new String[]{});\n        assertThat(actual, equalTo(new HashMap<>()));\n\n        actual = Main.wordCount(new String[]{\"Eggs\"});\n        Map<String, Integer> expected = Stream.of(new Object[][] {\n                {\"Eggs\", 1}\n        }).collect(Collectors.toMap(d -> (String) d[0], d -> (Integer) d[1]));\n\n        assertThat(actual, equalTo(expected));\n\n        actual = Main.wordCount(new String[]{\"Eggs\", \"Bacon\", \"SPAM\", \"Eggs\", \"Bacon\", \"SPAM\", \"Eggs\", \"SPAM\", \"Water\"});\n        expected = Stream.of(new Object[][] {\n                {\"Eggs\", 3},\n                {\"Bacon\", 2},\n                {\"SPAM\", 3},\n                {\"Water\", 1}\n        }).collect(Collectors.toMap(d -> (String) d[0], d -> (Integer) d[1]));\n        assertThat(actual, equalTo(expected));\n\n        /*assertThat(actual, equalTo(\n                Map.of(\n                        \"Eggs\", 3,\n                        \"Bacon\", 2,\n                        \"SPAM\", 3,\n                        \"Water\", 1\n                )\n        ));*/\n\n        actual = Main.wordCount(new String[]{\"1\", \"2\", \"3\", \"4\", \"5\", \"2\", \"3\", \"4\", \"5\", \"3\", \"4\", \"5\", \"4\", \"5\", \"5\"});\n        expected = Stream.of(new Object[][] {\n                {\"1\", 1},\n                {\"2\", 2},\n                {\"3\", 3},\n                {\"4\", 4},\n                {\"5\", 5}\n        }).collect(Collectors.toMap(d -> (String) d[0], d -> (Integer) d[1]));\n        assertThat(actual, equalTo(expected));\n        /*\n        assertThat(actual, equalTo(\n                Map.of(\n                        \"1\", 1, \"2\", 2, \"3\", 3, \"4\", 4, \"5\", 5\n                )\n        ));\n        */\n    }\n\n\n    @Test(timeOut = 1000)\n    public void testMostFrequentWord() {\n        String actual = Main.mostFrequentWord(new String[]{});\n        assertThat(actual, equalTo(null));\n\n        actual = Main.mostFrequentWord(new String[]{\"Eggs\"});\n        assertThat(actual, equalTo(\"Eggs\"));\n\n        actual = Main.mostFrequentWord(new String[]{\"1\", \"2\", \"3\", \"4\", \"5\", \"2\", \"3\", \"4\", \"5\", \"3\", \"4\", \"5\", \"4\", \"5\", \"5\"});\n        assertThat(actual, equalTo(\"5\"));\n\n        actual = Main.mostFrequentWord(new String[]{\"Eggs\", \"Bacon\", \"SPAM\", \"Eggs\", \"Bacon\", \"SPAM\", \"Eggs\", \"SPAM\", \"Water\"});\n        assertTrue(actual.matches(\"Eggs|SPAM\"));\n    }\n\n    @Test(timeOut = 1000)\n    public void testOnlyEvenWords() {\n        List<String> actual = Main.onlyEvenWords(Arrays.asList());\n        assertThat(actual, equalTo(Arrays.asList()));\n\n        actual = Main.onlyEvenWords(Arrays.asList(\"a\"));\n        assertThat(actual, equalTo(Arrays.asList()));\n\n        actual = Main.onlyEvenWords(Arrays.asList(\"b\",\"o\", \"b\"));\n        assertThat(actual, equalTo(Arrays.asList(\"b\")));\n\n        actual = Main.onlyEvenWords(Arrays.asList(\"c\", \"c\"));\n        assertThat(actual, equalTo(Arrays.asList(\"c\")));\n\n        actual = Main.onlyEvenWords(Arrays.asList(\"a\",\"b\", \"a\", \"c\", \"a\", \"d\", \"a\"));\n        assertThat(actual, equalTo(Arrays.asList(\"a\",\"a\")));\n\n        actual = Main.onlyEvenWords(Arrays.asList(\"a\", \"b\", \"b\", \"a\", \"a\"));\n        assertThat(actual, equalTo(Arrays.asList(\"b\", \"a\")));\n\n        actual = Main.onlyEvenWords(Arrays.asList(\"a\", \"b\", \"b\", \"b\", \"a\", \"c\", \"a\", \"a\"));\n        assertThat(actual, equalTo(Arrays.asList(\"b\", \"a\", \"a\")));\n\n        actual = Main.onlyEvenWords(Arrays.asList(\"a\",\"b\", \"b\", \"b\", \"a\", \"c\", \"a\", \"a\", \"a\", \"b\", \"a\"));\n        assertThat(actual, equalTo(Arrays.asList(\"b\",\"a\",\"a\", \"b\", \"a\")));\n\n        actual = Main.onlyEvenWords(Arrays.asList(\"a\",\"b\",\"c\"));\n        assertThat(actual, equalTo(Arrays.asList()));\n    }\n\n    @Test(timeOut = 1000)\n    public void testOnlyEvenCharacters() {\n        String actual = Main.onlyEvenCharacters(\"\");\n        assertThat(actual, equalTo(\"\"));\n\n        actual = Main.onlyEvenCharacters(\"aba\");\n        assertThat(actual, equalTo(\"a\"));\n\n        actual = Main.onlyEvenCharacters(\"bob\");\n        assertThat(actual, equalTo(\"b\"));\n\n        actual = Main.onlyEvenCharacters(\"cc\");\n        assertThat(actual, equalTo(\"c\"));\n\n        actual = Main.onlyEvenCharacters(\"abacada\");\n        assertThat(actual, equalTo(\"aa\"));\n\n        actual = Main.onlyEvenCharacters(\"abbaa\");\n        assertThat(actual, equalTo(\"ba\"));\n\n        actual = Main.onlyEvenCharacters(\"abbbacaa\");\n        assertThat(actual, equalTo(\"baa\"));\n\n        actual = Main.onlyEvenCharacters(\"abbbacaaaba\");\n        assertThat(actual, equalTo(\"baaba\"));\n\n        actual = Main.onlyEvenCharacters(\"abc\");\n        assertThat(actual, equalTo(\"\"));\n    }\n}\n","isTest":true},{"path":"strings.md","contents":"# PR02 String and map\n\nKaust Gitis: `PR02Strings`\n\nPakk Gitis: `ee.taltech.iti0202.strings`\n\nKlassi nimi: `Main`\n\nÜlesandeks on teha neli lihtsat meetodit, kus kasutatakse `Map`i, ehk Pythonist tuttavat `dict` andmetüüpi.\n\n---\n\nEnne ülesande lahendamist soovitan lugeda Mapi kohta [javadocist](https://ained.ttu.ee/javadoc/map.html?highlight=kujutis).\n\n## `wordCount`\n\nKlassikaline ülesanne, koosta meetod, mis saab sisendiks järjendi sõnedest ning tagastab\nsõnastiku/paisktabeli (*map/dict*), kus on olemas võti-väärtus paarid kõikide sõnade esinemissagedustega.\n\n## `mostFrequentWord`\n\nLeia kõige sagedamini esinev sõne järjendis. \nKui selliseid sõnesi on mitu, tagasta nendest suvaline.\n\n## `onlyEvenWords`\nKoosta meetod, mis võtab sisendiks listi sõnedest ning tagastab listi sõnedest. \n\nTagastatav sõned valitakse järgnevalt:\n\nLoop'i üle sõneded\n- kui sõne esineb listis teist, neljandat, kuuendat jne. korda, siis lisa sõne tulemusse.\n- kui sõne esineb listis esimest, kolmandat, viiendat jne. korda, siis jäte sõne vahele.\n\nNäiteid:\n- `[\"tere\", \"tere\", \"vanakere\"]` -> `[\"tere\"]`\n- `[\"foo\", \"bar\", \"baz\", \"baz\", \"bar\", \"foo\"]` -> `[\"baz\", \"bar\", \"foo\"]`\n- `[\"a\", \"b\", \"b\", \"a\"]` -> `[\"b\", \"a\"]`\n- `[\"a\", \"b\", \"a\", \"b]` -> `[\"a\", \"b\"]`\n- `[\"eggs\", \"bacon\", \"SPAM\", \"ham\", \"SPAM\", \"SPAM\"]` -> `[\"SPAM\"]`\n\n\n## `onlyEvenCharacters`\n\nKoosta meetod, mis võtab sisendiks sõne ning tagastab sõne. \n\nTagastatav sõne koostatakse järgneva algoritmiga:\n\nLoop'i üle sõne\n- kui täht esineb sõnes teist, neljandat, kuuendat jne. korda, siis lisa täht tulemusse.\n- kui täht esineb sõnes esimest, kolmandat, viiendat jne. korda, siis jäte täht vahele.\n\nNäiteid:\n- `aabbcc` -> `abc`\n- `abccba` -> `cba`\n- `abba` -> `ba`\n- `abab` -> `ab`\n- `abbccc` -> `abc`\n- `abc bac cba` -> `bac `\n\n\n## Mall\n\n```java\npackage ee.taltech.iti0202.strings;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n    /**\n     * Classic count the words exercise.\n     * <p>\n     * From input count all the words and collect results to map.\n     *\n     * @param sentence array of strings, can't be null.\n     * @return map containing all word to count mappings.\n     */\n    public static Map<String, Integer> wordCount(String[] sentence) {\n        return new HashMap<>();\n    }\n\n\n    /**\n     * Find the most frequent word in given array of strings.\n     *\n     * If there are multiple most frequent words to choose from pick any of them.\n     *\n     * @param sentence array of strings, can't be null.\n     * @return most frequent word in the sentence\n     */\n    public static String mostFrequentWord(String[] sentence) {\n        return \"TODO\";\n    }\n\n    /**\n     * Loop over the given list of strings to build a resulting list of string like this:\n     * when a string appears the 2nd, 4th, 6th, etc. time in the list, append the string to the result.\n     * <p>\n     * Return the empty list if no string appears a 2nd time.\n     * <p>\n     * Use map to count times that string has appeared.\n     *\n     * @param words input list to filter\n     * @return list of strings matching criteria\n     */\n    public static List<String> onlyEvenWords(List<String> words) {\n        return new ArrayList<String>();\n    }\n\n    /**\n     * Loop over the given string to build a result string like this:\n     * when a character appears the 2nd, 4th, 6th, etc. time in the string, append the character to the result.\n     * <p>\n     * Return the empty string if no character appears a 2nd time.\n     * <p>\n     * Use map to count times that character has appeared.\n     * Easy way to get char array (char[]) from string: input.toCharArray();\n     *\n     * @param input string\n     * @return string\n     */\n    public static String onlyEvenCharacters(String input) {\n        return \"FooBar\";\n    }\n\n\n    public static void main(String[] args) {\n        System.out.println(wordCount(new String[]{})); // empty\n        System.out.println(wordCount(new String[]{\"eggs\", \"SPAM\", \"eggs\", \"bacon\", \"SPAM\", \"bacon\", \"SPAM\"})); // {bacon=2, eggs=2, SPAM=3}\n\n        System.out.println();\n        System.out.println(mostFrequentWord(new String[]{})); // null\n        System.out.println(mostFrequentWord(new String[]{\"SPAM\", \"SPAM\", \"eggs\", \"bacon\", \"and\", \"SPAM\"})); // SPAM\n\n        System.out.println();\n        System.out.println(onlyEvenWords(Arrays.asList(\"tere\", \"tere\", \"vanakere\"))); // [tere]\n        System.out.println(onlyEvenWords(Arrays.asList(\"foo\", \"bar\", \"baz\", \"baz\", \"bar\", \"foo\"))); // [baz, bar, foo]\n        System.out.println(onlyEvenWords(Arrays.asList(\"a\", \"b\", \"b\", \"a\"))); // [b, a]\n        System.out.println(onlyEvenWords(Arrays.asList(\"a\", \"b\", \"a\", \"b\"))); // [a, b]\n        System.out.println(onlyEvenWords(Arrays.asList(\"eggs\", \"bacon\", \"SPAM\", \"ham\", \"SPAM\", \"SPAM\"))); // [SPAM]\n\n        System.out.println();\n        System.out.println(onlyEvenCharacters(\"aaa\")); // a\n        System.out.println(onlyEvenCharacters(\"aabbcaca\")); // abca\n        System.out.println(onlyEvenCharacters(\"bob\")); // b\n        System.out.println(\"\\\"\" + onlyEvenCharacters(\"abc\") + \"\\\"\");// \"\"\n    }\n}\n\n```","isTest":true},{"path":"PR02Strings.iml","contents":"<file in binary format or unable to read file>","isTest":false},{"path":"src/ee/taltech/iti0202/strings/Main.java","contents":"package ee.taltech.iti0202.strings;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class Main {\n    /**\n     * Classic count the words exercise.\n     * <p>\n     * From input count all the words and collect results to map.\n     *\n     * @param sentence array of strings, can't be null.\n     * @return map containing all word to count mappings.\n     */\n    public static HashMap<String, Integer> wordCount(String[] sentence) {\n        HashMap<String, Integer> dictionary = new HashMap<>();\n        for (String item : sentence) {\n            if (dictionary.containsKey(item)) {\n                dictionary.put(item, dictionary.get(item) + 1);\n            } else {\n                dictionary.put(item, 1);\n            }\n        }\n\n        return dictionary;\n    }\n\n    /**\n     * Find the most frequent word in given array of strings.\n     * <p>\n     * If there are multiple most frequent words to choose from pick any of them.\n     *\n     * @param sentence array of strings, can't be null.\n     * @return most frequent word in the sentence\n     */\n    public static String mostFrequentWord(String[] sentence) {\n        HashMap<String, Integer> map = wordCount(sentence);\n        String mostFrequent = null;\n        int highestOccurence = 0;\n        for (String element : map.keySet()) {\n            if (map.get(element) > highestOccurence) {\n                highestOccurence = map.get(element);\n                mostFrequent = element;\n            }\n        }\n        return mostFrequent;\n    }\n\n    /**\n     * Loop over the given list of strings to build a resulting list of string like this:\n     * when a string appears the 2nd, 4th, 6th, etc. time in the list, append the string to the result.\n     * Return the empty list if no string appears a 2nd tim\n     * Use map to count times that string has appeared.\n     *\n     * @param words input list to filter\n     * @return list of strings matching criteria\n     */\n    public static List<String> onlyEvenWords(List<String> words) {\n        List<String> apply = new ArrayList<>();\n        ArrayList<String> answer = new ArrayList<>();\n        for (String elem : words) {\n            if (apply.contains(elem)) {\n                apply.remove(elem);\n                answer.add(elem);\n            } else {\n                apply.add(elem);\n            }\n        }\n        return answer;\n    }\n\n    /**\n     * Loop over the given string to build a result string like this:\n     * when a character appears the 2nd, 4th, 6th, etc. time in the string, append the character to the result.\n     * <p>\n     * Return the empty string if no character appears a 2nd time.\n     * <p>\n     * Use map to count times that character has appeared.\n     * Easy way to get char array (char[]) from string: input.toCharArray();\n     *\n     * @param input string\n     * @return string\n     */\n    public static String onlyEvenCharacters(String input) {\n        List<String> apply = new ArrayList<>();\n        StringBuilder answer = new StringBuilder();\n        for (String elem : input.split(\"\")) {\n            if (apply.contains(elem)) {\n                apply.remove(elem);\n                answer.append(elem);\n            } else {\n                apply.add(elem);\n            }\n        }\n        return answer.toString();\n    }\n\n\n    public static void main(String[] args) {\n        System.out.println(wordCount(new String[]{})); // empty\n        System.out.println(wordCount(new String[]{\"eggs\", \"SPAM\", \"eggs\", \"bacon\", \"SPAM\", \"bacon\", \"SPAM\"}));\n\n        System.out.println();\n        System.out.println(mostFrequentWord(new String[]{})); // null\n        System.out.println(mostFrequentWord(new String[]{\"SPAM\", \"SPAM\", \"eggs\", \"bacon\", \"and\", \"SPAM\"})); // SPAM\n\n        System.out.println();\n\n        System.out.println();\n        System.out.println(onlyEvenCharacters(\"aaa\")); // a\n        System.out.println(onlyEvenCharacters(\"aabbcaca\")); // abca\n        System.out.println(onlyEvenCharacters(\"bob\")); // b\n        System.out.println(\"\\\"\" + onlyEvenCharacters(\"abc\") + \"\\\"\"); // \"\"\n    }\n}\n\n","isTest":false}],"identifier":"FILEWRITER","result":"SUCCESS"},{"code":102,"diagnosticList":[],"identifier":"COMPILER","result":"SUCCESS"},{"code":500,"identifier":"TESTNG","result":"SUCCESS","securityViolation":false,"testContexts":[{"unitTests":[{"status":"PASSED","weight":1,"description":"","printExceptionMessage":false,"printStackTrace":false,"timeElapsed":5,"groupsDependedUpon":[],"methodsDependedUpon":[],"name":"testOnlyEvenCharacters","stackTrace":null,"exceptionClass":null,"exceptionMessage":null,"stdout":[],"stderr":[]},{"status":"PASSED","weight":1,"description":"","printExceptionMessage":false,"printStackTrace":false,"timeElapsed":162,"groupsDependedUpon":[],"methodsDependedUpon":[],"name":"testMostFrequentWord","stackTrace":null,"exceptionClass":null,"exceptionMessage":null,"stdout":[],"stderr":[]},{"status":"PASSED","weight":1,"description":"","printExceptionMessage":false,"printStackTrace":false,"timeElapsed":29,"groupsDependedUpon":[],"methodsDependedUpon":[],"name":"testWordCount","stackTrace":null,"exceptionClass":null,"exceptionMessage":null,"stdout":[],"stderr":[]},{"status":"PASSED","weight":1,"description":"","printExceptionMessage":false,"printStackTrace":false,"timeElapsed":12,"groupsDependedUpon":[],"methodsDependedUpon":[],"name":"testOnlyEvenWords","stackTrace":null,"exceptionClass":null,"exceptionMessage":null,"stdout":[],"stderr":[]}],"name":"ee.taltech.iti0202.strings.MainTest (TestNG)","file":"ee.taltech.iti0202.strings.MainTest","startDate":1574746615333,"endDate":1574746618516,"mode":"VERBOSE","welcomeMessage":"","identifier":1,"count":4,"passedCount":4,"weight":4,"grade":100.0}],"totalCount":4,"totalGrade":100.0,"totalPassedCount":4},{"code":2147483647,"identifier":"REPORT","output":"TEST RESULTS\n\n* Checkstyle report *\n\nFound errors: 0\n\n\n\n\n* Compiler report *\n\nCompilation succeeded.\n\n* Unit tests *\n\n\nee.taltech.iti0202.strings.MainTest (TestNG)\nTue Nov 26 05:36:58 UTC 2019\n ---\nSUCCESS: testOnlyEvenCharacters\n\t5 msecs, weight: 1 unit\nSUCCESS: testMostFrequentWord\n\t162 msecs, weight: 1 unit\nSUCCESS: testWordCount\n\t29 msecs, weight: 1 unit\nSUCCESS: testOnlyEvenWords\n\t12 msecs, weight: 1 unit\n\nPassed unit tests: 4/4\nFailed unit tests: 0\nSkipped unit tests: 0\nGrade: 100.0%\n\nOverall grade: 100.0%\n","result":"SUCCESS"}]}